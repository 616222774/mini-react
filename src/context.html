<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>React Context</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"
    />
  </head>

  <body>
    <div id="root">React Context</div>
    <script>
      function propagateContextChange(
        workInProgress,
        context,
        changedBits,
        renderLanes
      ) {
        var fiber = workInProgress.child;

        while (fiber !== null) {
          var nextFiber = void 0; // Visit this fiber.

          var list = fiber.dependencies;
          // 首先判断这个fiber是否有dependencies，如果没有，说明这个fiber没有订阅任何context
          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.firstContext;
            // 如果这个fiber有订阅context，则判断是否是当前Provider的context
            while (dependency !== null) {
              // 检查context是否匹配
              if (
                dependency.context === context &&
                (dependency.observedBits & changedBits) !== 0
              ) {
                // 匹配到了context，说明这个组件订阅了当前Provider的context，我们需要给这个fiber调度更新
                if (fiber.tag === ClassComponent) {
                  // 如果是类组件，则创建一个更新对象update，并标记为强制更新
                  var update = createUpdate(
                    NoTimestamp,
                    pickArbitraryLane(renderLanes)
                  );
                  update.tag = ForceUpdate;
                  // 添加到更新队列
                  enqueueUpdate(fiber, update);
                }

                fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                var alternate = fiber.alternate;

                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                }

                scheduleWorkOnParentPath(fiber.return, renderLanes);

                list.lanes = mergeLanes(list.lanes, renderLanes);

                break;
              }

              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            // 如果是相同的Provider，则不用继续遍历了，因为相同的嵌套的Provider，内部的消费组件取最里层的，外层的Provider变化
            // 和里面的消费组件没啥关系
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else {
            // 继续遍历子节点
            nextFiber = fiber.child;
          }

          if (nextFiber === null) {
            // 没有子节点，则继续遍历兄弟节点
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                // 所有fiber节点已经遍历完成，退出
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                nextFiber = sibling;
                break;
              }
              // 如果没有兄弟节点，则查找父节点的兄弟节点
              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }
    </script>
  </body>
</html>
