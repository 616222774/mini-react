<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>React Context</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"
    />
  </head>

  <body>
    <div id="root">React Context</div>
    <script>
      function beginWork(current, workInProgress, renderLanes) {
        var updateLanes = workInProgress.lanes;

        if (current !== null) {
          var oldProps = current.memoizedProps;
          var newProps = workInProgress.pendingProps;

          if (
            oldProps !== newProps ||
            hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            false
          ) {
            // If props or context changed, mark the fiber as having performed work.
            // This may be unset if the props are determined to be equal later (memo).
            didReceiveUpdate = true;
          } else if (!includesSomeLane(renderLanes, updateLanes)) {
            didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
            // the begin phase. There's still some bookkeeping we that needs to be done
            // in this optimized path, mostly pushing stuff onto the stack.

            switch (workInProgress.tag) {
              case ContextProvider: {
                var newValue = workInProgress.memoizedProps.value;
                pushProvider(workInProgress, newValue);
                break;
              }
            }

            return bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
          } else {
            if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              // This is a special case that only exists for legacy mode.
              // See https://github.com/facebook/react/pull/19216.
              didReceiveUpdate = true;
            } else {
              // An update was scheduled on this fiber, but there are no new props
              // nor legacy context. Set this to false. If an update queue or context
              // consumer produces a changed value, it will set this to true. Otherwise,
              // the component will assume the children have not changed and bail out.
              didReceiveUpdate = false;
            }
          }
        } else {
          didReceiveUpdate = false;
        }

        switch (workInProgress.tag) {
          case ContextProvider:
            return updateContextProvider(current, workInProgress, renderLanes);
        }
      }

      function propagateContextChange(
        workInProgress,
        context,
        changedBits,
        renderLanes
      ) {
        var fiber = workInProgress.child;

        while (fiber !== null) {
          var nextFiber = void 0; // Visit this fiber.

          var list = fiber.dependencies;

          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.firstContext;

            while (dependency !== null) {
              // Check if the context matches.
              if (
                dependency.context === context &&
                (dependency.observedBits & changedBits) !== 0
              ) {
                // Match! Schedule an update on this fiber.
                if (fiber.tag === ClassComponent) {
                  // Schedule a force update on the work-in-progress.
                  var update = createUpdate(
                    NoTimestamp,
                    pickArbitraryLane(renderLanes)
                  );
                  update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
                  // update to the current fiber, too, which means it will persist even if
                  // this render is thrown away. Since it's a race condition, not sure it's
                  // worth fixing.

                  enqueueUpdate(fiber, update);
                }

                fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                var alternate = fiber.alternate;

                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                }

                scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.

                list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
                // dependency list.

                break;
              }

              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            // Don't scan deeper if this is a matching provider
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
          } else {
            // Traverse down.
            nextFiber = fiber.child;
          }

          if (nextFiber !== null) {
            // Set the return pointer of the child to the work-in-progress fiber.
            nextFiber.return = fiber;
          } else {
            // No child. Traverse to next sibling.
            nextFiber = fiber;

            while (nextFiber !== null) {
              if (nextFiber === workInProgress) {
                // We're back to the root of this subtree. Exit.
                nextFiber = null;
                break;
              }

              var sibling = nextFiber.sibling;

              if (sibling !== null) {
                // Set the return pointer of the sibling to the work-in-progress fiber.
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              } // No more siblings. Traverse up.

              nextFiber = nextFiber.return;
            }
          }

          fiber = nextFiber;
        }
      }
    </script>
  </body>
</html>
