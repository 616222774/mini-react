<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>schedule源码</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"
    />
    <style>
      #animation {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100px;
        height: 100px;
        background: red;
        animation: myfirst 5s;
        animation-iteration-count: infinite;
      }

      @keyframes myfirst {
        from {
          width: 30px;
          height: 30px;
          border-radius: 0;
          background: red;
        }
        to {
          width: 300px;
          height: 300px;
          border-radius: 50%;
          background: yellow;
        }
      }
    </style>
  </head>

  <body>
    <button id="btn">perform work</button>
    <div id="animation">Animation</div>
    <script>
      const btn = document.getElementById("btn");
      const animate = document.getElementById("animation");
      let startTime;
      btn.onclick = () => {
        startTime = new Date().getTime();
        for (let i = 0; i < 3000; i++) {
          if (i === 2999) {
            scheduleCallback(() => {
              const start = new Date().getTime();
              while (new Date().getTime() - start < 2) {}
              const endTime = new Date().getTime();
              animate.innerHTML = endTime - startTime;
            });
          } else {
            scheduleCallback(() => {
              const start = new Date().getTime();
              while (new Date().getTime() - start < 2) {}
            });
          }
        }
      };
    </script>
    <script>
      const yieldInterval = 5;
      let deadline = 0;
      const channel = new MessageChannel();
      let port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      function performWorkUntilDeadline() {
        if (scheduledHostCallback) {
          // 当前宏任务事件开始执行
          let currentTime = new Date().getTime();
          // 计算当前宏任务事件结束时间
          deadline = currentTime + yieldInterval;
          const hasMoreWork = scheduledHostCallback(currentTime);
          if (!hasMoreWork) {
            scheduledHostCallback = null;
          } else {
            // 如果还有工作，则触发下一个宏任务事件
            port.postMessage(null);
          }
        }
      }
      function requestHostCallback(callback) {
        scheduledHostCallback = callback;
        port.postMessage(null);
      }

      let taskQueue = [];
      let currentTask = null;
      let isHostCallbackScheduled = false;
      function flushWork(initialTime) {
        return workLoop(initialTime);
      }

      function workLoop(initialTime) {
        currentTask = taskQueue[0];

        while (currentTask) {
          if (new Date().getTime() >= deadline) {
            // 当前的currentTask还没过期，但是当前宏任务事件已经到达执行的最后期限，即我们需要
            // 将控制权交还给浏览器，剩下的任务在下一个事件循环中再继续执行
            //console.log("yield");
            break;
          }
          var callback = currentTask.callback;
          callback();

          taskQueue.shift();
          currentTask = taskQueue[0];
        }
        if (currentTask) {
          // 如果taskQueue中还有剩余工作，则返回true
          return true;
        } else {
          return false;
        }
      }
      function scheduleCallback(callback) {
        var newTask = {
          callback: callback,
        };
        taskQueue.push(newTask);
        if (!isHostCallbackScheduled) {
          isHostCallbackScheduled = true;
          requestHostCallback(flushWork);
        }
        return newTask;
      }
    </script>
  </body>
</html>
