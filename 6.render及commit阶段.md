### 问题剖析
在上一节，我们知道，performUnitOfWork每执行一次，都会追加真实的dom元素到容器中，此时我们在浏览器就能看到真实的页面。
但是render过程是可以中断的，就造成了我们看到的页面可能会不完整。显然不是我们要的效果。因此，我们修改一下performUnitOfWork，不执行添加dom到
父容器中的操作。并在render方法中保存rootFiber。

然后我们新增一个commitRoot方法，等所有的performUnitOfWork执行完成，就调用commitRoot，递归对rootFiber进行添加元素。
```jsx harmony
function createDom(fiber){
  const dom = fiber.type === 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(fiber.type);

  const isProperty = key => key !== 'children';

  Object.keys(fiber.props)
      .filter(isProperty)
      .forEach(name => {
        dom[name] = fiber.props[name];
      })

  return dom;
}


let nextUnitOfWork = null;
let wipRoot = null;
function render(element, container) {
  wipRoot = {
    dom: container, // 真实的dom
    props: {
      children: [element], // element为virtual dom树
    }
  }

  nextUnitOfWork = wipRoot;
}

function workLoop(deadline){
  let shouldYield = false;
  while(nextUnitOfWork && !shouldYield){
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    shouldYield = deadline.timeRemaining() < 1;
  }
  
  // 如果nextUnitOfWork为空，说明整个Fiber树构建已经完成，可以提交整棵树了。
  if(!nextUnitOfWork && wipRoot){
    commitRoot();
  }
  requestIdleCallback(workLoop)
}


requestIdleCallback(workLoop)


// 递归遍历整个wipRoot Fiber Tree，添加所有的节点到dom中。
function commitRoot(){
  commitWork(wipRoot.child);
  wipRoot = null;
}

function commitWork(fiber){
  if(!fiber) return;
  fiber.parent.dom.appendChild(fiber.dom);
  commitWork(fiber.child); // 先添加子节点
  commitWork(fiber.sibling); // 其次添加兄弟节点
}

function performUnitOfWork(fiber){
  if(!fiber.dom){
    fiber.dom = createDom(fiber); //为fiber创建真实的dom节点，并保存在fiber.dom属性中。
  }

// 不在performUnitOfWork中添加元素
  // 添加到父节点中。对于根root fiber而言，其dom节点已经是渲染到浏览器上的真实节点，也就是通过document.getElementById('root')
  // 获取到的dom。因此根root fiber是没有父节点的。
//  if(fiber.parent){
//    fiber.parent.dom.appendChild(fiber.dom);
//  }

  // 遍历每一个子元素，并创建fiber节点，设置fiber节点的子节点指针，兄弟节点指针，父节点三个指针。
  const elements = fiber.props.children;
  let index = 0;
  let prevSibling = null; // 用于设置兄弟节点的指针

  while(index < elements.length){
    const element = elements[index];

    // 为element创建相应的fiber节点
    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber, // 设置父节点指针
      dom: null, // 注意，此时还没有创建真实的dom
    }

    // 设置子节点及兄弟节点
    if(index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber;
    }
    prevSibling = newFiber;
    index++;
  }

  // 找到下一个可执行单元并返回
  // 1.先找子节点
  if(fiber.child){
    return fiber.child;
  }
  // 2.没有子节点就找兄弟节点
  let nextFiber = fiber;
  while(nextFiber){
    if(nextFiber.sibling){
      return nextFiber.sibling;
    }
    // 3.没有兄弟节点，则找父节点的兄弟节点
    nextFiber = nextFiber.parent;
  }


}
```

### 总结
performUnitOfWork只负责为每个元素创建真实的dom，并且遍历子元素，为每个子元素创建对应的Fiber节点。当递归遍历完所有的Element Tree节点后，
调用commitRoot，提交wipRoot。commitWork做的事情很简单，先将当前fiber节点添加到dom中，然后递归添加子节点，最后递归添加兄弟节点。

本节对应的代码在./lib/6.commit.js中。


### 问题分析
当我们第一次调用React.render方法时，在render方法内创建一个root fiber并保存到变量
wipRoot中，浏览器会循环执行performUnitOfWork，performUnitOfWork为每个fiber节点创建一个真实的dom节点，
并保存在fiber节点的dom属性中，**注意，performUnitOfWork创建了真实的dom，我们知道，操作真实的dom，代价其实是很昂贵的**。
当所有的performUnitOfWork执行完毕，此时fiber树构建完成，提交整棵树，就能在浏览器上看到我们想要的UI。

当我们第二次调用React.render方法时，在render方法内创建一个root fiber并保存变量到wipRoot中，XXXXX。。。可想而知，执行过程和
第一次调用React.render方法一样。

当我们第三次调用React.render方法时，，，可想而知执行过程也和第一次调用React.render方法一样。


。。。。

第n次调用时，执行过程和第一次调用React.render方法一样。。


那么问题来了，我们知道performUnitOfWork每次执行都会创建真实的dom节点，而创建真实的dom节点这个过程是比较昂贵的(操作dom的代价很高的).
如果每次调用render方法，我们都要重新去构建一棵fiber树，每棵fiber树的dom节点都重新创建，可想而知性能会不好。

那有没有可能，我在调用render时，只更新那些更新的节点？例如，可以使用一个变量保存着第一次调用React.render方法生成的Fiber Tree，
第二次调用React.render方法时，比较Element Tree和第一次生成的Fiber Tree的不同，只修改第一次的Fiber Tree上那些更新的节点，并更新到浏览器
中，此时浏览器对应的是第二次的Fiber  Tree。

当第三次调用React.render方法时，比较Element Tree和第二次生成的Fiber Tree，只修改第二次Fiber Tree上那些更新的节点。

如此下去，，性能肯定要更好。

因此，我们需要一个阶段，来对比Element Tree和当前浏览器UI对应的Fiber Tree的差异，并标记哪些Fiber节点是需要更新或者删除的。
