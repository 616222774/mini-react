## 学习目标

- rAF
- requestIdleCallback
- MessageChannel

## 屏幕刷新率

- 目前大多数设备的屏幕刷新率为 60 次/秒
- 浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致
- 页面是一帧一帧绘制出来的，当每秒绘制的帧数(FPS)达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿
- 每个帧的预算时间是 16.66 毫秒(1 秒/60)，因此我们写代码时力求一帧的工作量不超过 16ms

## 帧

- 每个帧的开头包括样式计算、布局和绘制
- JavaScript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript 执行两者是互斥的
- 如果某个任务执行时间过长，浏览器会推迟渲染

浏览器刷新频率和屏幕的刷新频率是怎么同步的？答案：通过 vSync 标记符，显卡会在每一帧开始时间给浏览器发送一个 vSync 标记符

## MessageChannel

- 目前 requestIdleCallback 只有 chrome 支持
- 所以目前 React 利用 MessageChannel 模拟了 requestIdleCallback，将回调延迟到绘制操作之后执行
- MessageChannel API 允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据
- MessageChannel 创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过 postMessage 发送数据，而一个端口只要绑定了 onmessage 就可以接收另一个端口传过来的数据
- MessageChannel 是一个宏任务

至于为什么 MessageChannel 回调的执行时机会比 setTimeout 早，这里简单解释一下，浏览器的宏任务队列其实是一个有序集合，这意味着队列里到期的事件不一定会按入队的顺序执行，因为 DOM Event 的优先级比计时器高，所以会出现上面的打印结果。


微任务是在本次页面更新前执行




 ## issues
 - [https://github.com/facebook/react/pull/16214](https://github.com/facebook/react/pull/16214)

 - [https://programmer.group/exploring-the-inner-of-react-postmessage-scheduler.html](https://programmer.group/exploring-the-inner-of-react-postmessage-scheduler.html)