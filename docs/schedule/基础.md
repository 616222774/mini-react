## react 优先级

下面是 react 优先级（reactPriorityLevel）

```js
// Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.
export const ImmediatePriority: ReactPriorityLevel = 99;
export const UserBlockingPriority: ReactPriorityLevel = 98;
export const NormalPriority: ReactPriorityLevel = 97;
export const LowPriority: ReactPriorityLevel = 96;
export const IdlePriority: ReactPriorityLevel = 95;
```

lane 优先级转换成 react 优先级：

```js
// 实际上这个函数名叫lanePriorityToReactPriority直观一点
function lanePriorityToSchedulerPriority(lanePriority) {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediatePriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdlePriority;

    case NoLanePriority:
      return NoPriority;

    default: {
    }
  }
}
```

## 调度优先级

SchedulerPriority 调度优先级：

```js
Scheduler_ImmediatePriority：1；
Scheduler_UserBlockingPriority：2
Scheduler_NormalPriority：3
Scheduler_LowPriority：4
Scheduler_IdlePriority：5
```

react 优先级转换成调度优先级：

```js
function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority$1:
      return Scheduler_ImmediatePriority;

    case UserBlockingPriority$2:
      return Scheduler_UserBlockingPriority;

    case NormalPriority$1:
      return Scheduler_NormalPriority;

    case LowPriority$1:
      return Scheduler_LowPriority;

    case IdlePriority$1:
      return Scheduler_IdlePriority;

    default: {
    }
  }
}
```

> 总的来说就是，先将 lane 优先级转换成 react 优先级，react 优先级再转换成调度优先级

## issues

- [https://github.com/facebook/react/pull/16214](https://github.com/facebook/react/pull/16214)

- [https://programmer.group/exploring-the-inner-of-react-postmessage-scheduler.html](https://programmer.group/exploring-the-inner-of-react-postmessage-scheduler.html)

https://blog.crimx.com/2020/06/30/%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95-react-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AE%89%E5%85%A8/

https://opy-bbt.github.io/2020/06/13/%E4%BB%8E%E6%B5%8B%E8%AF%95%E7%9C%8Breact%E6%BA%90%E7%A0%81-scheduler/

https://twitter.com/dan_abramov/status/699395627264962561


web worker：https://github.com/facebook/react/issues/3092


generator：https://github.com/facebook/react/issues/7942


看到这里，估计有同学会想为什么不使用 web worker 执行耗时长的任务。实际上，在我们这个案例中，使用 web worker 是完全可行的。关于 react 为啥不使用 web worker 或者 generator 调度任务，具体可以看这个[issue](https://github.com/facebook/react/issues/3092#issuecomment-183154290)以及这个[issue](https://github.com/facebook/react/issues/7942)

本来 requestIdlecallback 是比较理想的 API，但由于兼容性问题，所以 react 没有采用。

关于为什么不使用 requestAnimationFrame，可以看[这个](https://github.com/facebook/react/pull/16214)