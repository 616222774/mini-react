> 本章介绍构建副作用链表的算法。React 在 render 阶段构建副作用链表。其中在 reconcile children 时，如果节点需要删除，则添加进副作用链表。同时在 completeUnitOfWork 阶段添加其他副作用的节点

## 问题

- 删除，添加，修改节点哪个副作用先执行？

- 对于某个 fiber 节点来说，如果有子节点需要删除，那么被删除的子节点在这个 fiber 节点副作用链表的表头

## 深入理解 React Fiber 副作用链表的构建算法

React 在 render 阶段从根节点开始协调子节点(reconcile children)，并给有副作用的 fiber 节点添加标记(flag)。

```js
function collectEffectList(returnFiber, completedWork) {
  if (!returnFiber.firstEffect) {
    returnFiber.firstEffect = completedWork.firstEffect;
  }
  if (completedWork.lastEffect) {
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
    }
    returnFiber.lastEffect = completedWork.lastEffect;
  }
  const flags = completedWork.flags;
  if (flags) {
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork;
    } else {
      returnFiber.firstEffect = completedWork;
    }
    returnFiber.lastEffect = completedWork;
  }
}

const Placement = 2;
const rootFIber = { key: "rootFiber" };
const fiberA = { key: "A", flags: Placement };
const fiberB = { key: "B", flags: Placement };
const fiberC = { key: "C", flags: Placement };

// rootFiber -> A -> BC

collectEffectList(fiberA, fiberB);
collectEffectList(fiberA, fiberC);
collectEffectList(rootFIber, fiberA);
```

```js
// 副作用链表(Effect List)
// 为了避免遍历fiber树寻找有副作用的fiber节点，所以有了effectList
// 在fiber树构建过程中，每当一个fiber节点的flags字段不为 NoFlags 时，代表需要执行副作用，就把该fiber节点添加到
// effectList中
// effectList是一个单向链表，firstEffect代表链表中的第一个fiber节点，lastEffect代表链表中的最后一个fiber节点
// fiber树的构建是深度优先的，也就是先向下构建子级fiber节点，子级节点构建完成后，再向上构建父级Fiber节点，所以effectList
// 中总是子级Fiber节点在前面
// fiber节点构建完成的操作执行在 completeUnitOfWork 方法，在这个方法里，不仅会对节点完成构建，
// 也会将有flags的fiber节点添加到effectlist中
function collectEffectList(returnFiber, completedWork) {
  if (!returnFiber) return;
  // 如果父节点没有effectList，那就让父节点的firstEffect链表头指向当前节点
  if (!returnFiber.firstEffect) {
    returnFiber.firstEffect = completedWork.firstEffect;
  }
  if (completedWork.lastEffect) {
    // 并且父节点也有链表尾时
    if (returnFiber.lastEffect) {
      // 将当前节点的effectList挂载到父节点的链表尾部
      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
    }

    returnFiber.lastEffect = completedWork.lastEffect;
  }
  const flags = completedWork.flags;
  // 如果此完成的fiber有副作用，那么就需要添加到effectList里
  if (flags) {
    // 如果父fiber有lastEffect的话，说明父fiber已经有effect链表
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork;
    } else {
      returnFiber.firstEffect = completedWork;
    }
    returnFiber.lastEffect = completedWork;
  }
}
```
