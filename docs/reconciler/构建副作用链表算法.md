> 本章介绍构建副作用链表的算法。React 在 render 阶段构建副作用链表。

## 知识点

- 了解什么是 fiber 副作用，以及 fiber 中与副作用相关的属性
- 了解如何构建副作用链表

其中在 reconcile children 时，如果节点需要删除，则添加进副作用链表。同时在 completeUnitOfWork 阶段添加其他副作用的节点

- 删除，添加，修改节点哪个副作用先执行？
- 对于某个 fiber 节点来说，如果有子节点需要删除，那么被删除的子节点在这个 fiber 节点副作用链表的表头

## 深入理解 React Fiber 副作用链表的构建算法

React 在 render 阶段构建副作用链表。其中，在 reconcile children(协调子节点) 时，如果旧的子节点需要删除，则标记为 Deletion 副作用，并添加到父节点的副作用链表中，这个操作在 beginWork 阶段完成。其余类型的副作用节点都在 completeUnitOfWork 阶段添加到父节点的副作用链表中。

假设我们在更新时需要渲染以下新的节点，A、B、D 都是需要更新的，而 C 是需要删除的

```jsx
// 旧的节点
<div id="A">
  <div id="B"></div>
  <div id="C"></div>
  <div id="D"></div>
</div>
// 更新后新的节点
<div id="A">
  <div id="B"></div>
  <div id="D"></div>
</div>
```

我们按照 React 渲染流程(如果对渲染流程不熟悉，可以查看[这篇文章](https://github.com/lizuncong/mini-react/blob/master/docs/render/%E6%B7%B1%E5%85%A5%E6%A6%82%E8%BF%B0%20React%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E4%B8%BB%E6%B5%81%E7%A8%8B.md))来拆解这个过程

```js
// React渲染流程主要源码
function performUnitOfWork(unitOfWork) {
  // beginWork主要逻辑就是协调子节点，即根据最新的react element元素和旧的fiber节点进行对比
  const next = beginWork(current, unitOfWork, subtreeRenderLanes); // next 就是当前节点unitOfWork的子节点
  if (next === null) {
    // 如果没有子节点，说明当前节点可以完成了
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

对于节点A，我们调用 `performUnitOfWork(div#A)` 开始工作：
- 执行beginWork协调子节点，发现

从这里也可以看出，**删除的副作用是最先加到父节点的副作用链表中的，其次才是其他类型的副作用节点。** 因为在 render 阶段，React 首先调用 beginWork 协调当前节点(比如 A)的子节点：

- 如果当前节点(A)有子节点，并且有子节点需要删除，则将需要删除的子节点添加到当前节点(A)的副作用链表中。
- 如果当前节点(A)没有子节点，说明当前子节点可以完成了，调用 completeUnitOfWork 完成当前节点。在 completeUnitOfWork 中判断如果当前节点(A)有副作用，则将当前节点(A)添加到他的节点的副作用链表中。

从以上过程也可以看出，**React 是自底向上构建副作用链表的**

## fiber 副作用

React 通过 fiber flag 属性标记副作用。如果不明白副作用是啥，可以看这篇文章[深入理解 React Fiber 副作用](https://github.com/lizuncong/mini-react/blob/master/docs/fiber/%E7%9B%98%E7%82%B9fiber%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E6%A0%87%E5%BF%97flags.md)。

fiber 中与副作用相关的属性如下：

```js
function FiberNode() {
  // ...
  // Effects
  this.flags = NoFlags;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;
  // ...
}
```

## fiber 节点副作用链表

每个 fiber 节点都维护一个**单向的**具有副作用的**子节点链表**，其中 firstEffect 指向表头。lastEffect 指向表尾。子节点之间通过 nextEffect 连接。

假设有如下节点，同时假设他们的副作用都是 Placement

```jsx
<div id="A">
  <div id="B"></div>
  <div id="C"></div>
</div>;
// 对应的fiber节点属性将如下所示：
const fiberA = {
  flags: Placement,
  nextEffect: null,
  firstEffect: null,
  lastEffect: null,
};
const fiberB = {
  flags: Placement,
  nextEffect: null,
  firstEffect: null,
  lastEffect: null,
};
const fiberC = {
  flags: Placement,
  nextEffect: null,
  firstEffect: null,
  lastEffect: null,
};
```

React 在 render 阶段从根节点开始协调子节点(reconcile children)，并给有副作用的 fiber 节点添加标记(flag)。

```js
function collectEffectList(returnFiber, completedWork) {
  if (!returnFiber.firstEffect) {
    returnFiber.firstEffect = completedWork.firstEffect;
  }
  if (completedWork.lastEffect) {
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
    }
    returnFiber.lastEffect = completedWork.lastEffect;
  }
  const flags = completedWork.flags;
  if (flags) {
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork;
    } else {
      returnFiber.firstEffect = completedWork;
    }
    returnFiber.lastEffect = completedWork;
  }
}

const Placement = 2;
const rootFIber = { key: "rootFiber" };
const fiberA = { key: "A", flags: Placement };
const fiberB = { key: "B", flags: Placement };
const fiberC = { key: "C", flags: Placement };

// rootFiber -> A -> BC

collectEffectList(fiberA, fiberB);
collectEffectList(fiberA, fiberC);
collectEffectList(rootFIber, fiberA);
```

```js
// 副作用链表(Effect List)
// 为了避免遍历fiber树寻找有副作用的fiber节点，所以有了effectList
// 在fiber树构建过程中，每当一个fiber节点的flags字段不为 NoFlags 时，代表需要执行副作用，就把该fiber节点添加到
// effectList中
// effectList是一个单向链表，firstEffect代表链表中的第一个fiber节点，lastEffect代表链表中的最后一个fiber节点
// fiber树的构建是深度优先的，也就是先向下构建子级fiber节点，子级节点构建完成后，再向上构建父级Fiber节点，所以effectList
// 中总是子级Fiber节点在前面
// fiber节点构建完成的操作执行在 completeUnitOfWork 方法，在这个方法里，不仅会对节点完成构建，
// 也会将有flags的fiber节点添加到effectlist中
function collectEffectList(returnFiber, completedWork) {
  if (!returnFiber) return;
  // 如果父节点没有effectList，那就让父节点的firstEffect链表头指向当前节点
  if (!returnFiber.firstEffect) {
    returnFiber.firstEffect = completedWork.firstEffect;
  }
  if (completedWork.lastEffect) {
    // 并且父节点也有链表尾时
    if (returnFiber.lastEffect) {
      // 将当前节点的effectList挂载到父节点的链表尾部
      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
    }

    returnFiber.lastEffect = completedWork.lastEffect;
  }
  const flags = completedWork.flags;
  // 如果此完成的fiber有副作用，那么就需要添加到effectList里
  if (flags) {
    // 如果父fiber有lastEffect的话，说明父fiber已经有effect链表
    if (returnFiber.lastEffect) {
      returnFiber.lastEffect.nextEffect = completedWork;
    } else {
      returnFiber.firstEffect = completedWork;
    }
    returnFiber.lastEffect = completedWork;
  }
}
```
