> 异常捕获介绍

React 16 使用了更具弹性的错误处理策略：错误边界。默认情况下，如果在组件的渲染或生命周期方法中抛出错误，整个组件树将从根目录卸载。这可以防止显示损坏的数据。但是，这可能不是理想的用户体验。

## 错误边界

关于错误边界的定义，可以看[React 官方文档](https://reactjs.org/docs/error-boundaries.html)

错误边界可以只会捕获下列几种异常，这也是 React 能够处理的异常：

- 子组件树渲染期间的错误
- 生命周期方法中的错误
- 构造函数中的错误

错误边界无法捕获以下场景中产生的错误：

- 事件处理
- 异步代码，例如 setTimeout 或 requestAnimationFrame 回调函数
- 服务端渲染
- 错误边界组件自身抛出来的错误

错误边界只能是 Class 组件，如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界

**自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。这里所说的错误指的是 render 阶段抛出的错误，包括 render 函数、生命周期方法、构造函数等。事件处理，异步代码里未被捕获的异常并不会导致页面崩溃**

React 不需要错误边界来捕获事件处理器中的错误。与 render 方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React 仍然能够知道需要在屏幕上显示什么。

## React 是怎么捕获已经被吞噬的异常的？

比如下面中，`setCount({ a: 1 })` 由于 count 是一个对象，在 render 阶段会报错，但按理会被 promise 的 catch 语句捕获，而不会抛出错误，但是 React 是如何做到的呢？

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <div
      onClick={() => {
        Promise.resolve()
          .then(() => {
            setCount({ a: 1 });
          })
          .catch(() => {
            console.log("Swallowed!");
          });
      }}
    >
      {count}
    </div>
  );
};
// 或者
const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <div
      onClick={() => {
        setTimeout(() => {
          setCount({ a: 1 });
        }, 1000);
      }}
    >
      {count}
    </div>
  );
};
```

## 如何只捕获 React 渲染过程相关的异常

React 只会捕获 React 组件渲染过程相关的异常，而不会捕获事件处理器中的异常。为了实现这个目的，React 在执行 React 组件渲染前监听 error 事件，而在组件结束渲染后取消监听该事件即可

为什么说 dispatchEvent 就能模拟并替代 try/catch 呢？

dispatchEvent 能够同步执行代码
与浏览器原生事件不同，原生事件是由 DOM 派发的，并通过 event loop 异步调用事件处理程序，而 dispatchEvent() 则是同步调用事件处理程序。在调用 dispatchEvent() 后，所有监听该事件的事件处理程序将在代码继续前执行并返回。

上文出自 dispatchEvent 的 MDN 文档，由此可见： dispatchEvent 能够同步执行代码 ，这意味着在事件处理方法执行完成前，可以阻塞 dispatchEvent 后续的代码执行，同时这也是 try/catch 的特征之一。

dispatchEvent 抛的异常不冒泡
这些 event handlers 运行在一个嵌套的调用栈中：他们会阻塞调用直到他们处理完毕，但是异常不会冒泡。
准确来说，是：通过 dispatchEvent 触发的事件回调方法，异常不会冒泡；这意味着，即便抛出异常，也只是会终止事件回调方法本身的执行，而 dispatchEvent() 上下文的代码并不会收到影响。下面写个 DEMO 验证下这个特性：

```js
function cb() {
  console.log("开始执行回调");
  throw "dispatchEvent的事件处理函数抛异常了";
  console.log("走不到这里的");
}

/* 准备一个虚拟事件 */
const eventType = "this-is-a-custom-event";
const fakeEvent = document.createEvent("Event");
fakeEvent.initEvent(eventType, false, false);

/* 准备一个虚拟DOM节点 */
const fakeNode = document.createElement("fake");
fakeNode.addEventListener(eventType, cb, false); // 挂载

console.log("dispatchEvent执行前");
fakeNode.dispatchEvent(fakeEvent);
console.log("dispatchEvent执行后");

// 上述代码运行的结果是：
// dispatchEvent执行前
// 开始执行回调
// Uncaught dispatchEvent的事件处理函数抛异常了
// dispatchEvent执行后
```

从上述 DEMO 可以看出，尽管 dispatchEvent 的事件处理函数抛了异常，但依然还是能够继续执行 dispatchEvent 后续的代码（即 DEMO 中的 console.log()）。

实现一个简易版的 render 异常捕获器
接下来，让我们把 GlobalEventHandlers.onerror 和 EventTarget.dispatchEvent 结合起来，就能够实现一个简易版的 render 异常捕获器：

```js
function exceptionCatcher(func) {
  /* 准备一个虚拟事件 */
  const eventType = "this-is-a-custom-event";
  const fakeEvent = document.createEvent("Event");
  fakeEvent.initEvent(eventType, false, false);

  /* 准备一个虚拟DOM节点 */
  const fakeNode = document.createElement("fake");
  fakeNode.addEventListener(eventType, excuteFunc, false); // 挂载

  window.addEventListener("error", handleError);
  fakeNode.dispatchEvent(fakeEvent); // 触发执行目标方法
  window.addEventListener("error", handleError); // 清除副作用

  function excuteFunc() {
    func();
    fakeNode.removeEventListener(evtType, excuteFunc, false);
  }

  function handleError() {
    // 将异常交给错误边界来处理
  }
}
```

## 链接

- [React16 错误处理](https://zh-hans.reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)
- [服务端渲染的一篇文章](https://medium.com/@aickin/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67)
- [Fiber 架构](https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/)

- [issue](https://github.com/facebook/react/issues/4982)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Swiper demo</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"
    />
  </head>

  <body>
    <div id="container">
      container
      <div id="child">
        child
        <div>grand son</div>
      </div>
    </div>
    <script>
      window.onerror = (e) => {
        console.log("window on error捕获的错误", e);
      };
      window.onunhandledrejection = (e) => {
        console.log("window on unhandledrejection捕获的错误", e);
      };
      // demo1 被window.onerror捕获
      // setTimeout(() => {
      //   console.log(aaa);
      // }, 0);
      // demo 2 不会被window.onerror捕获
      // setTimeout(() => {
      //   try {
      //     console.log(aaa);
      //   } catch (e) {
      //     console.log("set time out 捕获的异常", e);
      //   }
      // }, 0);
      // demo3 不会被window.onerror捕获，但会被window.onunhandledrejection捕获
      Promise.resolve().then(() => {
        console.log("不会被window.onerror捕获", test);
      });
      // Promise.resolve()
      //   .then(() => {
      //     console.log(promise.resolve);
      //   })
      //   .catch((err) => {
      //     console.log("catch...", err);
      //   });
    </script>
  </body>
</html>
```
