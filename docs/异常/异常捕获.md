> 异常捕获介绍

React 16 使用了更具弹性的错误处理策略：错误边界。默认情况下，如果在组件的渲染或生命周期方法中抛出错误，整个组件树将从根目录卸载。这可以防止显示损坏的数据。但是，这可能不是理想的用户体验。

## 错误边界

关于错误边界的定义，可以看[React 官方文档](https://reactjs.org/docs/error-boundaries.html)

错误边界可以只会捕获下列几种异常，这也是 React 能够处理的异常：

- 子组件树渲染期间的错误
- 生命周期方法中的错误
- 构造函数中的错误

错误边界无法捕获以下场景中产生的错误：

- 事件处理
- 异步代码，例如 setTimeout 或 requestAnimationFrame 回调函数
- 服务端渲染
- 错误边界组件自身抛出来的错误

错误边界只能是 Class 组件，如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界

**自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。这里所说的错误指的是 render 阶段抛出的错误，包括 render 函数、生命周期方法、构造函数等。事件处理，异步代码里未被捕获的异常并不会导致页面崩溃**

React 不需要错误边界来捕获事件处理器中的错误。与 render 方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React 仍然能够知道需要在屏幕上显示什么。

## React 是怎么捕获已经被吞噬的异常的？

比如下面中，`setCount({ a: 1 })` 由于 count 是一个对象，在 render 阶段会报错，但按理会被 promise 的 catch 语句捕获，而不会抛出错误，但是 React 是如何做到的呢？

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <div
      onClick={() => {
        Promise.resolve()
          .then(() => {
            setCount({ a: 1 });
          })
          .catch(() => {
            console.log("Swallowed!");
          });
      }}
    >
      {count}
    </div>
  );
};
// 或者
const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <div
      onClick={() => {
        setTimeout(() => {
          setCount({ a: 1 });
        }, 1000);
      }}
    >
      {count}
    </div>
  );
};
```

## 如何只捕获 React 渲染过程相关的异常

React 只会捕获 React 组件渲染过程相关的异常，而不会捕获事件处理器中的异常。为了实现这个目的，React 在执行 React 组件渲染前监听 error 事件，而在组件结束渲染后取消监听该事件即可

## 链接

- [React16 错误处理](https://zh-hans.reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)
- [服务端渲染的一篇文章](https://medium.com/@aickin/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67)
- [Fiber 架构](https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/)

- [issue](https://github.com/facebook/react/issues/4982)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Swiper demo</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"
    />
  </head>

  <body>
    <div id="container">
      container
      <div id="child">
        child
        <div>grand son</div>
      </div>
    </div>
    <script>
      window.onerror = (e) => {
        console.log("window on error捕获的错误", e);
      };
      window.onunhandledrejection = (e) => {
        console.log("window on unhandledrejection捕获的错误", e);
      };
      // demo1 被window.onerror捕获
      // setTimeout(() => {
      //   console.log(aaa);
      // }, 0);
      // demo 2 不会被window.onerror捕获
      // setTimeout(() => {
      //   try {
      //     console.log(aaa);
      //   } catch (e) {
      //     console.log("set time out 捕获的异常", e);
      //   }
      // }, 0);
      // demo3 不会被window.onerror捕获，但会被window.onunhandledrejection捕获
      Promise.resolve().then(() => {
        console.log("不会被window.onerror捕获", test);
      });
      // Promise.resolve()
      //   .then(() => {
      //     console.log(promise.resolve);
      //   })
      //   .catch((err) => {
      //     console.log("catch...", err);
      //   });
    </script>
  </body>
</html>
```
